#Prvo cemo pokrenuti program da bismo vidjeli kako se on izvrsava

Starting program: /home/raso/purv_zadace/1/zadaca_radislav 
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".

Program received signal SIGSEGV, Segmentation fault.
__strlen_avx2 () at ../sysdeps/x86_64/multiarch/strlen-avx2.S:74
74	../sysdeps/x86_64/multiarch/strlen-avx2.S: No such file or directory.

#Vidimo da program dobija gresku, segmentation fault, unutar funckije __strlen_avx2


#Da bismo saznali gdje se greska mogla dogoditi, postavicemo breakpoint na main funckiju, te cemo ispisati asembler kod radi analize


Breakpoint 1 at 0x555555555151: file zadaca_radislav.c, line 9.
Starting program: /home/raso/purv_zadace/1/zadaca_radislav 
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".

Breakpoint 1, main () at zadaca_radislav.c:9
9	    printf("%s\n", array[0]);
Dump of assembler code for function main:
zadaca_radislav.c:
7	int main() {
   0x0000555555555149 <+0>:	endbr64 
   0x000055555555514d <+4>:	push   %rbp
   0x000055555555514e <+5>:	mov    %rsp,%rbp

8	
9	    printf("%s\n", array[0]);
=> 0x0000555555555151 <+8>:	movzbl 0x2eb8(%rip),%eax        # 0x555555558010 <array>
   0x0000555555555158 <+15>:	movsbl %al,%eax
   0x000055555555515b <+18>:	mov    %eax,%esi
   0x000055555555515d <+20>:	lea    0xea0(%rip),%rax        # 0x555555556004
   0x0000555555555164 <+27>:	mov    %rax,%rdi
   0x0000555555555167 <+30>:	mov    $0x0,%eax
   0x000055555555516c <+35>:	call   0x555555555050 <printf@plt>

10	
11	    return (0);
   0x0000555555555171 <+40>:	mov    $0x0,%eax

12	}
   0x0000555555555176 <+45>:	pop    %rbp
   0x0000555555555177 <+46>:	ret    
End of assembler dump.

#Iz ovog mozemo da vidimo da se main funkcija sastoji samo iz jedne linije, a to je poziv funkcije printf, dakle mozemo zakljuciti da se greska dogadja bas na toj liniji koda

#Printf je funckija iz standardne C biblioteke, te iz tog razloga mozemo pretpostaviti da je funkcija ispravno napisana i da ne postoje greske unutar nje

#Dakle, ostaje nam jedini moguci problem, a to su argumenti koje proslijedjemo ovoj funckiji, koji se proslijedjuju preko registara rdi i rsi

#Iz tog razloga cemo posmatrati sta se desava sa ovim registrima prilikom poziva ove funckije


1: /a $rdi = 0x1
Invalid character '#' in expression.
2: /a $rsi = 0x7fffffffdef8
9	    printf("%s\n", array[0]);
1: /a $rdi = 0x1
2: /a $rsi = 0x7fffffffdef8
0x000055555555515b	9	    printf("%s\n", array[0]);
1: /a $rdi = 0x1
2: /a $rsi = 0x7fffffffdef8
0x000055555555515d	9	    printf("%s\n", array[0]);
1: /a $rdi = 0x1
2: /a $rsi = 0x68

#Vidimo da je nakon izvrsavanja prethodne funckije u registar rsi postavljen prvi argument - array[0] = 0x68 (ASCII kod za 'h')
#Sa ovim mozemo da uvidimo i razumijemo gresku koja se desila
#Naime, format %s zahtjeva kao argument pokazivacki tip, koji je adresa koja vodi do prvog karaktera nekog stringa
#U ovom slucaju kao taj argument je proslijedjeno 0x68 sto znaci da ce funckija printf pokusati da pristupi bas toj adresi
#Obzirom na to da adresi 0x68 nije dozvoljen pristup iz naseg programa, niti znamo sta je na njoj, bilo kakav pokusaj dereferenciranja te adrese dovesce do greske - segmentation fault


